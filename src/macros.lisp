(in-package :v)
(defmacro :0 (x) `(elt ,x 0))
(defmacro :1 (x) `(elt ,x 1))
(defmacro :2 (x) `(elt ,x 2))
(defmacro :3 (x) `(elt ,x 3))
(defmacro :4 (x) `(elt ,x 4))
(defmacro :5 (x) `(elt ,x 5))
(defmacro :6 (x) `(elt ,x 6))
(defmacro :7 (x) `(elt ,x 7))
(defmacro :8 (x) `(elt ,x 8))
(defmacro :9 (x) `(elt ,x 9))
(defmacro a (&rest r) `(cl:apply   ,@r))
(defmacro c (&rest r) `(cl:funcall ,@r))
(defmacro n (&rest r) `(cl:progn   ,@r))
(defmacro if3 (a b c) `(cl:if ,a ,b ,c))
(defmacro if2 (a b)   `(cl:if ,a ,b))
(defmacro mv-prog1 (&rest r) `(multiple-value-prog1 ,@r))
(defmacro mv-setq (&rest r) `(multiple-value-setq ,@r))
(defmacro mv-list (&rest r) `(multiple-value-list ,@r))
(defmacro mv-bind (&rest r) `(multiple-value-bind ,@r))
(defmacro mv-call (&rest r) `(multiple-value-call ,@r))
(defmacro get-mchar (c)
  `(let ((c ,c)) (if c (get-macro-character c))))
(defmacro set-mchar (c x &optional y)
  `(set-macro-character
    c (lambda    (&optional _1 _2 _3 _4 _5 _6 _7 _8 _9)
	(declare (ignorable _1 _2 _3 _4 _5 _6 _7 _8 _9))
	,x)
    y))
